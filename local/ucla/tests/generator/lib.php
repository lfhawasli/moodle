<?php
// This file is part of Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Generator class to help in the writing of unit tests for the local_ucla
 * plugin.
 *
 * @copyright 2013 UC Regents
 * @package   local_ucla
 * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

defined('MOODLE_INTERNAL') || die();

global $CFG;
$moodleroot = __DIR__ . '/../../../..';
require_once($moodleroot . '/'.$CFG->admin.'/tool/uclacoursecreator/uclacoursecreator.class.php');
require_once($moodleroot . '/'.$CFG->admin.'/tool/uclacourserequestor/lib.php');
require_once($moodleroot . '/'.$CFG->admin.'/tool/uclasiteindicator/lib.php');
require_once($moodleroot . '/local/ucla/lib.php');
require_once($moodleroot . '/lib/testing/generator/data_generator.php');

/**
 * local_ucla data generator
 *
 * @package    local_ucla
 * @category   phpunit
 * @copyright  UC Regents
 */
class local_ucla_generator extends testing_data_generator {

    /**
     * Catalog numbers to use for autogeneration. Format: 0000SSPP.
     * @var array
     */
    public $crsidxs = array('0266    ',
                            '0004AL  ',
                            '0019    ',
                            '0162C   ',
                            '0089HC  ',
                            '0098XA  ',
                            '0105A   ',
                            '0223C M ',
                            '0001C   ',
                            '0180F   ');

    /**
     * Divisions to use for autogeneration.
     * @var array
     */
    public $divisions = array('AA' => 'SCHOOL OF THE ARTS AND ARCHITECTURE',
                              'AR' => 'ARCHITECTURE AND URBAN PLANNING',
                              'BB' => 'BASIC BIOMEDICAL SCIENCES',
                              'DN' => 'DENTISTRY',
                              'ED' => 'EDUCATION',
                              'GS' => 'LETTERS AND SCIENCE',
                              'HU' => 'HUMANITIES',
                              'LF' => 'LIFE SCIENCE',
                              'LW' => 'LAW',
                              'MG' => 'MANAGEMENT',
                              'MN' => 'MEDICINE',
                              'NS' => 'NURSING',
                              'PS' => 'PHYSICAL SCIENCE',
                              'SS' => 'SOCIAL SCIENCE',
                              'TF' => 'SCHOOL OF THEATER, FILM, AND TELEVISION');


    /**
     * Section numbers to use for autogeneration. Format: P000SS.
     * @var array
     */
    public $secidxs = array(' 001  ',
                            ' 002  ',
                            ' 003  ',
                            ' 004  ',
                            ' 005  ',
                            ' 006  ',
                            ' 007  ',
                            ' 008  ',
                            ' 009  ',
                            ' 010  ');

    /**
     * Subject areas to use for autogeneration.
     * @var array 
     */
    public $subjareas = array('E&S SCI',
                              'LBR&WS',
                              'WOM STD',
                              'COMM ST',
                              'SPAN',
                              'DIS STD',
                              'BIOINFO',
                              'ASIA AM',
                              'FILM TV',
                              'GENDER');

    /**
     * Terms to use for autogeneration.
     * @var array
     */
    public $terms = array('12S', '121', '12F', '13W', '13S');

    /**
     * Given an array for a course, generate given class. Given array entries
     * must be the same as those suitable for insertion into ucla_reg_classinfo.
     *
     * Expected array keys (if not present, will be autogenerated):
     *  subj_area, coursenum, sectnum, crsidx, enrolstat
     *
     * @throws dml_exception
     *
     * @param array $courses    If not passed, then will randomly create a
     *                          course that may or may not be a crosslist. If an
     *                          array is passed and some keys are not specified,
     *                          then those missing elements will be randomly
     *                          generated. If multiple course records are given,
     *                          then it will join all those courses as a
     *                          crosslist.
     *
     * @return array            Returns array of ucla_request_classes entries.
     *
     * @throws Exception
     */
    public function create_class($courses = NULL) {

        // Make sure public/private is enabled at the site level, so that
        // public/private event handlers work properly.
        set_config('enablepublicprivate', 1);

        $classtocreate = array();

        // Whenever we affect ucla_request_classes table, should purge caches.
        $cache = cache::make('local_ucla', 'urcmappings');
        $cache->purge();

        // Were we called with any parameters?
        if (is_null($courses)) {
            // Course has 25% chance to be crosslisted with 2-5 crosslists.
            if (rand(1, 4) == 4) {
                // This is going to be crosslisted, so figure out how many
                // crosslists to make.
                $numcrosslists = rand(2, 4);
                for ($i = 1; $i <= $numcrosslists; $i++) {
                    $classtocreate[] = array();
                }
            } else {
                $classtocreate[] = array();
            }
        } else if (isset($courses[0]) && is_array($courses[0])) {
            // Crosslist found.
            $classtocreate = $courses;
        } else {
            // Noncrosslist course requested.
            $classtocreate[] = $courses;
        }

        // Generate any missing fields.
        $giventerm = '';
        $existingshortnames = array();
        foreach ($classtocreate as &$course) {
            $this->set_termsrs($giventerm, $course);
            $this->set_shortname($course, $existingshortnames);

            $existingshortnames[] = $course['shortname'];

            // If enrolstat is not given, then default to open ("O").
            if (empty($course['enrolstat'])) {
                $course['enrolstat'] = 'O';
            }
        }

        // Only need to generate category for hostcourse (first entry).
        $this->set_division($classtocreate[0]);

        // Make shell course first.
        $courseobj = $this->create_course(
                array('shortname'   => $classtocreate[0]['shortname'],
                      'category'    => $classtocreate[0]['category'],
                      'format'      => 'ucla',
                      'numsections' => 10));

        // Add course to appropiate ucla tables.
        $this->insert_ucla_reg_classinfo($classtocreate);
        $this->insert_ucla_request_classes($courseobj->id, $classtocreate);

        // Finished creating courses, so return array of created course requests.
        return ucla_map_courseid_to_termsrses($courseobj->id);
    }


    /**
     * Creates a given collaboration site.
     *
     * @param array $course     To specify a certain site type set 'type'
     *                          parameter.
     *
     * @return array            Returns created course object.
     */
    public function create_collab($course) {

        // Make sure public/private is enabled at the site level, so that
        // public/private event handlers work properly.
        set_config('enablepublicprivate', 1);

        // Get site type.
        $sitetype = 'test'; // Default type.
        if (isset($course['type'])) {
            $types = siteindicator_manager::get_types_list();
            if (in_array($course['type'], array_keys($types))) {
                $sitetype = $course['type'];
            }
            unset($course['type']);
        }

        // Set defaults.
        if (!isset($course['format'])) {
            $course['format'] = 'ucla';
        }
        if (!isset($course['numsections'])) {
            $course['numsections'] = 10;
        }

        // Make shell course first.
        $courseobj = $this->create_course($course);

        // Add course to the ucla_siteindicator table.
        $site = new stdClass();
        $site->courseid = $courseobj->id;
        $site->type = $sitetype;
        siteindicator_site::create($site);

        return $courseobj;
    }

    /**
     * Create the roles needed to do enrollment. Note, that these roles will not
     * have the same capabilities as the real roles, they are just roles with
     * the same name as needed.
     *
     * @return array        Returns an array of shortname to roleid.
     */
    public function create_ucla_roles() {
        global $DB;
        $retval = array();

        $roles[] = array('name' => 'Instructor',
                         'shortname' => 'editinginstructor',
                         'archetype' => 'editingteacher');
        $roles[] = array('name' => 'Supervising Instructor',
                         'shortname' => 'supervising_instructor',
                         'archetype' => 'editingteacher');
        $roles[] = array('name' => 'Teaching Assistant (admin)',
                         'shortname' => 'ta_admin',
                         'archetype' => 'editingteacher');
        $roles[] = array('name' => 'TA Instructor',
                         'shortname' => 'ta_instructor',
                         'archetype' => 'editingteacher');
        $roles[] = array('name' => 'Teaching Assistant',
                         'shortname' => 'ta',
                         'archetype' => 'student');
        $roles[] = array('name' => 'Student Facilitator',
                         'shortname' => 'studentfacilitator',
                         'archetype' => 'editingteacher');

        foreach ($roles as $role) {
            $retval[$role['shortname']] = create_role($role['name'],
                    $role['shortname'], '', $role['archetype']);
        }

        // Although we didn't create it, we need the roleid for student.
        $student = $DB->get_record('role', array('shortname' => 'student'));
        $retval[$student->shortname] = $student->id;

        return $retval;
    }

    /**
     * Create a test user with UCLA specific data.
     * 
     * @param array|stdClass $record
     * @param array $options
     * @return stdClass user record
     */
    public function create_user($record = NULL, array $options = NULL) {
        global $CFG, $DB;

        $record = (array) $record;

        if (!isset($record['mnethostid'])) {
            $record['mnethostid'] = $CFG->mnet_localhost_id;
        }
        $record['auth'] = 'shibboleth';

        // Make sure the user has username with @ucla.edu and idnumber that is
        // a 9 digit number.
        $i = $this->usercounter;        
        if (!isset($record['username'])) {
            $record['username'] = 'username' . $i . '@ucla.edu';
            $j = 2;
            while ($DB->record_exists('user',
                    array('username' => $record['username'],
                'mnethostid' => $record['mnethostid']))) {
                $record['username'] = 'username' . $i . '_' . $j . '@ucla.edu';
                $j++;
            }
        } else if (preg_match('/@ucla.edu$/', $record['username']) !== 1) {
            debugging('Given username does not end with @ucla.edu');
        }
        if (!isset($record['idnumber'])) {
            do {
                $record['idnumber'] = rand(100000000, 999999999);
            } while ($DB->record_exists('user',
                    array('username' => $record['idnumber'],
                'mnethostid' => $record['mnethostid'])));
        } else if (strlen((string) $record['idnumber']) != 9) {
            debugging('Given idnumber is not 9 digits long');
        }

        // If email isn't given, then use username. Cannot depend on Moodle's
        // create user to create an email address, because it will append
        // @example.com to the username, which is not a valid email.
        if (!isset($record['email'])) {
            $record['email'] = $record['username'];
        }

        // Create the user using the regular data generator method.
        return parent::create_user($record, $options);
    }

    /**
     * Crosslists the given children array to the parent course.
     *
     * Sometimes in tests we want to do something to a course, combine it with
     * another course, and then test to see what happens.
     *
     * NOTE: This will not merge the contents of the children courses into the
     * parent. It will only update the UCLA registrar tables and invalidate any
     * existing caches.
     *
     * Procedure:
     *  1) Update ucla_request_classes table to change courseid for children to
     *     match parent courseid. Also need to set hostcourse for children to 0.
     *  2) Delete children courses.
     *
     * @param stdClass $parent  Expecting to be ucla_request_classes entry.
     * @param array $children   Expecting array of ucla_request_classes entries.
     * @return boolean          False on error, otherwise true.
     */
    public function crosslist_courses(stdClass $parent, array $children) {
        global $DB;

        try {
            // Will throw an exception if parent course does not exist.
            get_course($parent->courseid);

            // Might run into problems, so need to be able to rollback.
            $transaction = $DB->start_delegated_transaction();

            // 1) Update ucla_request_classes table to change courseid for children
            // to  match parent courseid. Also need to set hostcourse for children
            // to 0.
            $courseidstodelete = array();
            foreach ($children as $child) {
                // Make sure we are only crosslisting courses for the same term.
                if ($parent->term != $child->term) {
                    throw new Exception(sprintf('Cannot crosslist child ' .
                            'course (%s) with different term than parent (%s)',
                            $child->term, $parent->term));
                }

                if (!empty($child->courseid)) {
                    // No courseid set if course hasn't been built yet.
                    $courseidstodelete[$child->courseid] = $child->courseid;
                }
                $child->courseid = $parent->courseid;
                $child->hostcourse = 0;
                $child->action = UCLA_COURSE_BUILT;

                $DB->update_record('ucla_request_classes', $child);
            }

            // Now delete children courses.
            if (!empty($courseidstodelete)) {
                foreach ($courseidstodelete as $courseid) {
                    $result = delete_course($courseid);
                    if (!$result) {
                        throw new Exception('Cannot delete child course: ' .
                                            $courseid);
                    }
                }
            }

            $transaction->allow_commit();
        } catch(Exception $e) {
            $transaction->rollback($e);
            return false;
        }

        // Since mappings changed, purge all caches.
        $cache = cache::make('local_ucla', 'urcmappings');
        $cache->purge();

        return true;
    }

    /**
     * Formats Registrar format to display format:
     *     0000SSPP -> PP . int(0000) . SS
     *
     * @param string crsidx
     *
     * @return string           Returns formatted string.
     */
    private function format_crsidx($crsidx) {
        $num = intval(substr($crsidx, 0, 4));

        if (strlen($crsidx) < 5) {
            $ss = '  ';
        } else {
            if (strlen($crsidx) < 6) {
                $ss = $crsidx[4] . ' ';
            } else {
                $ss = $crsidx[4] . $crsidx[5];
            }
        }

        if (strlen($crsidx) < 7) {
            $pp = '  ';
        } else {
            if (strlen($crsidx) < 8) {
                $pp = $crsidx[6] . ' ';
            } else {
                $pp = $crsidx[6] . $crsidx[7];
            }
        }

        return trim(trim($pp) . $num . trim($ss));
    }

    /**
     * Formats Registrar format to display format:
     *    P000SS -> P+CSTR(CINT(000))+SS
     *
     * @param string $secidx
     *
     * @param string            Returns formatted string
     */
    function format_secidx($secidx) {
        $retval = '';
        if (strlen($secidx) <= 3) {
            // If the string length is ~3, then just convert it to int.
            $retval = intval($secidx);
        } elseif (strlen($secidx) == 5) {
            // Then maybe the last character doesn't exist... truncated.
            $num      = intval(substr($secidx, 1, 3));
            $ss       = trim(substr($secidx, 4, 1));
            $retval   = $num . $ss;
        } else {
            // All characters should be present.
            $p        = trim(substr($secidx, 0, 1));
            $num      = intval(substr($secidx, 1, 3));
            $ss       = trim(substr($secidx, 4, 2));
            $retval   = $p . $num . $ss;
        }

        return $retval;
    }

    /**
     * Inserts given courses array into the ucla_reg_classinfo table.
     *
     * @param array $courses
     */
    private function insert_ucla_reg_classinfo(array $courses) {
        global $DB;

        $firstentry = true;
        foreach ($courses as $course) {
            $classinfo = $course;

            unset($classinfo['shortname']);            
            unset($classinfo['category']);

            $DB->insert_record('ucla_reg_classinfo', $classinfo);
        }
    }

    /**
     * Inserts given courses array into the ucla_request_classes table.
     * 
     * Maps entries from courses array that correspond to the ucla_reg_classinfo
     * to the appropiate fields for ucla_request_classes and adds other
     * needed columns.
     *
     * @param int $courseid
     * @param array $courses
     */
    private function insert_ucla_request_classes($courseid, array $courses) {
        global $DB;

        // Get proper setid to use when inserting records into request table.
        $setid = $DB->get_field('ucla_request_classes',
                'MAX(setid) + 1 AS max_setid', array());

        $firstentry = true;
        foreach ($courses as $course) {
            $request = array();

            // Only the first entry should be the host course.
            if ($firstentry) {
                $request['hostcourse'] = 1;
                $firstentry = false;
            } else {
                $request['hostcourse'] = 0;
            }

            $request['term'] = $course['term'];
            $request['srs'] = $course['srs'];
            $request['department'] = $course['subj_area'];
            $request['setid'] = $setid;
            $request['action'] = UCLA_COURSE_BUILT;
            $request['course'] = $course['coursenum'].'-'.$course['sectnum'];
            $request['courseid'] = $courseid;

            $DB->insert_record('ucla_request_classes', $request);
        }
    }

    /**
     * Returns the power set of a one dimensional array, a 2-D array.
     * [a,b,c] -> [ [a], [b], [c], [a, b], [a, c], [b, c], [a, b, c] ]
     *
     * @source http://stackoverflow.com/a/6092999/6001
     *
     * @param array $in
     * @param int $minlength
     *
     * @return array
     */
    public function power_set(array $in, $minlength = 1) {
        $count = count($in);
        $members = pow(2, $count); 
        $return = array();
        for ($i = 0; $i < $members; $i++) {
            $b = sprintf("%0".$count."b",$i);
            $out = array();
            for ($j = 0; $j < $count; $j++) {
                if ($b{$j} == '1') $out[] = $in[$j];
            }
            if (count($out) >= $minlength) {
                $return[] = $out;
            }
        }
        return $return;
    }

    /**
     * Helper function to set division. Includes creating entry in
     * ucla_reg_division table and creating division category.
     *
     * @param array $course     Expected keys: division and subj_area
     */
    private function set_division(array &$course) {
        global $DB;

        if (empty($course['division'])) {
            $codes = array_keys($this->divisions);
            $course['division'] = $codes[array_rand($codes)];
        }

        // Make sure division exists in ucla_reg_division.
        if (!$DB->record_exists('ucla_reg_division',
                array('code' => $course['division']))) {
            if (empty($this->divisions[$course['division']])) {
                throw new Exception('Trying to add a non-existent division: ' .
                        $course['division']);
            }
            $DB->insert_record('ucla_reg_division',
                    array('code' => $course['division'],
                          'fullname' => $this->divisions[$course['division']]));
        }

        // Just put all courses into a category for their division.
        $divisioncategory = $DB->get_record('course_categories',
                array('name' => $this->divisions[$course['division']]));
        if (empty($divisioncategory)) {
            $divisioncategory = $this->create_category(
                    array('name' => $this->divisions[$course['division']]));
        }

        // Set category to division.
        $course['category'] = $divisioncategory->id;
    }

    /**
     * Helper function to generate a unique shortname.
     * 
     * @param array $course     Expected keys: term, session_group, subj_area,
     *                          crsidx, secidx. Will modify parameter to set
     *                          coursenum, sectnum, classidx, and shortname. As
     *                          well as set any missing expected values.
     * @param array $existingshortnames Other cross-lists that we are creating.
     */
    private function set_shortname(array &$course, array $existingshortnames) {
        global $DB;

        $autogenfields = array();
        while (true) {
            // Term and session_group should be predefined. Check if we need to
            // autogenerate the subj_area, crsidx, or secidx.

            // Check if we are looping again, because of the shortname already
            // exists, if so, regenerate another one.
            if (empty($course['subj_area']) || !empty($autogenfields['subj_area'])) {
                $course['subj_area'] = $this->subjareas[array_rand($this->subjareas)];
                $autogenfields['subj_area'] = TRUE;
            }
            if (empty($course['crsidx']) || !empty($autogenfields['crsidx'])) {
                $course['crsidx'] = $this->crsidxs[array_rand($this->crsidxs)];
                $autogenfields['crsidx'] = TRUE;
            }
            if (empty($course['secidx']) || !empty($autogenfields['secidx'])) {
                $course['secidx'] = $this->secidxs[array_rand($this->secidxs)];
                $autogenfields['secidx'] = TRUE;
            }

            // Course creator's make_course_shortname is expecting term,
            // session_group, subj_area, coursenum, sectnum.
            $course['coursenum'] = $this->format_crsidx($course['crsidx']);
            $course['sectnum'] = $this->format_secidx($course['secidx']);
            // It appears that classidx is just a clone of secidx.
            $course['classidx'] = $course['secidx'];

            $courseobject = (object) $course;

            // The make_course_shortname method is also expecting an object.
            $shortname = uclacoursecreator::make_course_shortname($courseobject);

            // If shortname exists, try to regenerate it again.
            if (!$DB->record_exists('course', array('shortname' => $shortname))) {
                if (!in_array($shortname, $existingshortnames)) {
                    $course['shortname'] = $shortname;
                    break;
                }
            }else if (empty($autogenfields)) {
                // Cannot autogenerate shortname, since it was hardcoded.
                throw new dml_exception('duplicatefieldname', $shortname);
            }
        }
    }

    /**
     * Helper function to generate a unique term/srs combination.
     *
     * @param string $giventerm For sanity sake, make sure all cross-lists have
     *                          the same term.
     * @param array $course     Expected keys: term, session_group, srs. Will
     *                          set any missing expected values.
     * @throws Exception
     */
    private function set_termsrs(&$giventerm, array &$course) {
        global $DB;

        $autogenfields = array();
        while (true) {            
            if (!empty($giventerm)) {
                if (empty($course['term'])) {
                    // Already had term set, so just use it.
                    $course['term'] = $giventerm;
                } else if ($course['term'] != $giventerm) {
                    // A term was hardcoded and it does not match the first
                    // cross-list.
                    throw new Exception('Mismatching terms');
                }
            }

            if (empty($course['term']) || !empty($autogenfields['term'])) {
                $course['term'] = $this->terms[array_rand($this->terms)];
                $autogenfields['term'] = TRUE;
            }
            if (empty($course['srs']) || !empty($autogenfields['srs'])) {
                $course['srs'] = rand(100000000, 999999999);
                $autogenfields['srs'] = TRUE;
            }

            if (!$DB->record_exists('ucla_request_classes',
                    array('term' => $course['term'], 'srs' => $course['srs']))) {
                if (is_summer_term($course['term'])) {
                    // Summer sessions have a session group set.
                    if (empty($course['session_group'])) {
                        $session_groups = array('A', 'C');
                        $course['session_group'] = $session_groups[array_rand($session_groups)];
                    }
                } else {
                    $course['session_group'] = '';
                }
                break;
            } else if (empty($autogenfields)) {
                // Term and SRS were hardcoded, cannot regen.
                $a = sprintf('term = %s and srs = %s', $course['term'], $course['srs']);
                throw new dml_exception('duplicatefieldname', $a);
            }
        }

        // No given term set before, so remember it for potential future calls.
        if (empty($giventerm)) {
            $giventerm = $course['term'];
        }
    }
}
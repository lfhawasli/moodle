<?php
// This file is part of the UCLA local plugin for Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Generator to help in the writing of unit tests for the local_ucla plugin.
 *
 * @package   local_ucla
 * @category  test
 * @copyright 2013 UC Regents
 * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */
defined('MOODLE_INTERNAL') || die();

global $CFG;
$moodleroot = __DIR__ . '/../../../..';
require_once($moodleroot . '/' . $CFG->admin . '/tool/uclacoursecreator/uclacoursecreator.class.php');
require_once($moodleroot . '/' . $CFG->admin . '/tool/uclacourserequestor/lib.php');
require_once($moodleroot . '/' . $CFG->admin . '/tool/uclasiteindicator/lib.php');
require_once($moodleroot . '/local/ucla/lib.php');
require_once($moodleroot . '/lib/testing/generator/data_generator.php');

/**
 * Data generator class.
 *
 * @copyright  2014 UC Regents
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */
class local_ucla_generator extends testing_data_generator {

    /**
     * Catalog numbers to use for autogeneration. Format: 0000SSPP.
     * @var array
     */
    public $crsidxs = array('0266    ',
        '0004AL  ',
        '0019    ',
        '0162C   ',
        '0089HC  ',
        '0098XA  ',
        '0105A   ',
        '0223C M ',
        '0001C   ',
        '0180F   ');

    /**
     * Section numbers to use for autogeneration. Format: P000SS.
     * @var array
     */
    public $secidxs = array(' 001  ',
        ' 002  ',
        ' 003  ',
        ' 004  ',
        ' 005  ',
        ' 006  ',
        ' 007  ',
        ' 008  ',
        ' 009  ',
        ' 010  ');

    /**
     * Subject areas to use for autogeneration.
     * @var array 
     */
    public $subjareas = array('E&S SCI',
        'LBR&WS',
        'WOM STD',
        'COMM ST',
        'SPAN',
        'DIS STD',
        'BIOINFO',
        'ASIA AM',
        'FILM TV',
        'GENDER');

    /**
     * Terms to use for autogeneration.
     * @var array
     */
    public $terms = array('12S', '121', '12F', '13W', '13S');

    /**
     * Given an array for a course, generate given class. Given array entries
     * must be the same as those suitable for insertion into ucla_reg_classinfo.
     *
     * Expected array keys (if not present, will be autogenerated):
     *  subj_area, coursenum, sectnum, crsidx, enrolstat
     *
     * @throws dml_exception
     *
     * @param array $courses    If not passed, then will randomly create a
     *                          course that may or may not be a crosslist. If an
     *                          array is passed and some keys are not specified,
     *                          then those missing elements will be randomly
     *                          generated. If multiple course records are given,
     *                          then it will join all those courses as a
     *                          crosslist.
     *
     * @return array            Returns array of ucla_request_classes entries.
     *
     * @throws Exception
     */
    public function create_class($courses = null) {

        // Make sure public/private is enabled at the site level, so that
        // public/private event handlers work properly.
        set_config('enablepublicprivate', 1);

        $classtocreate = array();

        // Whenever we affect ucla_request_classes table, should purge caches.
        $cache = cache::make('local_ucla', 'urcmappings');
        $cache->purge();

        // Were we called with any parameters?
        if (is_null($courses)) {
            // Course has 25% chance to be crosslisted with 2-5 crosslists.
            if (rand(1, 4) == 4) {
                // This is going to be crosslisted, so figure out how many
                // crosslists to make.
                $numcrosslists = rand(2, 4);
                for ($i = 1; $i <= $numcrosslists; $i++) {
                    $classtocreate[] = array();
                }
            } else {
                $classtocreate[] = array();
            }
        } else if (isset($courses[0]) && is_array($courses[0])) {
            // Crosslist found.
            $classtocreate = $courses;
        } else {
            // Noncrosslist course requested.
            $classtocreate[] = $courses;
        }

        // Generate any missing fields.
        $giventerm = '';
        $existingshortnames = array();
        foreach ($classtocreate as &$course) {
            $this->set_termsrs($giventerm, $course);
            $this->set_shortname($course, $existingshortnames);

            $existingshortnames[] = $course['shortname'];

            // If enrolstat is not given, then default to open ("O").
            if (empty($course['enrolstat'])) {
                $course['enrolstat'] = 'O';
            }
        }

        // Only need to generate category for hostcourse (first entry).
        $this->set_division($classtocreate[0]);

        // Make shell course first.
        $param = array('shortname' => $classtocreate[0]['shortname'],
                       'category' => $classtocreate[0]['category'],
                       'format' => 'ucla',
                       'numsections' => 10);
        if (!empty($classtocreate[0]['fullname'])) {
            // We sometimes need to specify the fullname in behat tests.
            $param['fullname'] = $classtocreate[0]['fullname'];
        }
        $courseobj = $this->create_course($param);

        // Add course to appropiate ucla tables.
        $this->insert_ucla_reg_classinfo($classtocreate);
        $this->insert_ucla_request_classes($courseobj->id, $classtocreate);

        // Finished creating classes, so return array of created course requests.
        return ucla_map_courseid_to_termsrses($courseobj->id);
    }

    /**
     * Creates a given collaboration site.
     *
     * @param array $course     To specify a certain site type set 'type'
     *                          parameter.
     *
     * @return array            Returns created course object.
     */
    public function create_collab($course) {

        // Make sure public/private is enabled at the site level, so that
        // public/private event handlers work properly.
        set_config('enablepublicprivate', 1);

        // Get site type.
        $sitetype = 'test'; // Default type.
        if (isset($course['type'])) {
            $types = siteindicator_manager::get_types_list();
            if (in_array($course['type'], array_keys($types))) {
                $sitetype = $course['type'];
            }
            unset($course['type']);
        }

        // Set defaults.
        if (!isset($course['format'])) {
            $course['format'] = 'ucla';
        }
        if (!isset($course['numsections'])) {
            $course['numsections'] = 10;
        }

        // Make shell course first.
        $courseobj = $this->create_course($course);

        // Add course to the ucla_siteindicator table.
        $site = new stdClass();
        $site->courseid = $courseobj->id;
        $site->type = $sitetype;
        siteindicator_site::create($site);

        return $courseobj;
    }


    /**
     * Helper function for create_ucla_roles function.  Creates a dummy role
     * based off of XML information.
     *
     * @param string $xml
     */
    protected function create_dummy_role($xml) {
        global $DB;
        if (core_role_preset::is_valid_preset($xml)) {
            $info = core_role_preset::parse_preset($xml);
            if (!$DB->get_record('role', array('shortname' => $info['shortname']))) {
                create_role($info['name'], $info['shortname'], $info['description'], $info['archetype']);
            }
        }
    }

    /**
     * Helper function for create_ucla_roles function.  Fully defines
     * a role from an xml file.  $shortname is used to retrieve dummy roles
     * for updating.
     *
     * @param string $xml role xml definition
     * @param string $shortname role shortname
     * @return array $role role definition
     */
    protected function define_role_from_xml($xml, $shortname) {
        global $DB;
        // Preset options.
        if ($role = $DB->get_record('role', array('shortname' => $shortname))) {
            $options = array(
                'shortname'     => 1,
                'name'          => 1,
                'description'   => 1,
                'permissions'   => 1,
                'archetype'     => 1,
                'contextlevels' => 1,
                'allowassign'   => 1,
                'allowoverride' => 1,
                'allowswitch'   => 1);
            $definitiontable = new tool_uclarolesmigration_import_table(context_system::instance(), $role->id);
            $definitiontable->force_preset($xml, $options);
            $definitiontable->save_changes();
            unset($definitiontable);
            return $role;
        }
    }

    /**
     * Helper function for create_ucla_roles function.
     * Checks $filepath to see if a file exists there, and
     * returns its contents if it exists.
     *
     * @param string $filepath
     * @return string file contents
     */
    protected function check_and_get_file($filepath) {
        if (is_file($filepath)) {
            return file_get_contents($filepath);
        } else {
            return null;
        }
    }

    /**
     * Create the roles needed to do enrollment. Note, that these roles will not
     * have the same capabilities as the real roles, they are just roles with
     * the same name as needed.
     *
     * @param array $rolestocreate
     * @return array Returns an array of shortname to roleid.
     */
    public function create_ucla_roles($rolestocreate = null) {
        global $CFG, $DB;
        $retval = array();

        // If rolestocreate is undefined, we assume that every role should be made from the fixtures.
        if (empty($rolestocreate)) {
            // Process each file with the *.xml extension and create dummy roles.
            $xmlfiles = glob($CFG->dirroot . '/local/ucla/tests/fixtures/roles/*.xml', GLOB_NOSORT);
            foreach ($xmlfiles as $file) {
                $xml = file_get_contents($file);
                $this->create_dummy_role($xml);
            }

            // Process each file with the *.xml extension and update/define each role.
            foreach ($xmlfiles as $file) {
                $xml = file_get_contents($file);
                if (core_role_preset::is_valid_preset($xml)) {
                    $shortname = basename($file, '.xml');
                    $role = $this->define_role_from_xml($xml, $shortname);
                    $retval[$role->shortname] = $role->id;
                }
            }

        } else {
            // Create dummy variable for each role.
            foreach ($rolestocreate as $roletocreate) {
                $filepath = $CFG->dirroot . '/local/ucla/tests/fixtures/roles/' . $roletocreate . '.xml';
                $xml = $this->check_and_get_file($filepath);
                if (is_null($xml)) {
                    continue;
                }
                $this->create_dummy_role($xml);
            }

            // Process and update/define each role.
            foreach ($rolestocreate as $roletocreate) {
                $filepath = $CFG->dirroot . '/local/ucla/tests/fixtures/roles/' . $roletocreate . '.xml';
                $xml = $this->check_and_get_file($filepath);
                if (is_null($xml)) {
                    continue;
                } else if (core_role_preset::is_valid_preset($xml)) {
                    $shortname = $roletocreate;
                    $role = $this->define_role_from_xml($xml, $shortname);
                    $retval[$role->shortname] = $role->id;
                }
            }
        }

        return $retval;
    }

    /**
     * Create a test user with UCLA specific data.
     * 
     * @param array|stdClass $record
     * @param array $options
     * @return stdClass user record
     */
    public function create_user($record = null, array $options = null) {
        global $CFG, $DB;

        $record = (array) $record;

        if (!isset($record['mnethostid'])) {
            $record['mnethostid'] = $CFG->mnet_localhost_id;
        }
        $record['auth'] = 'shibboleth';

        // Make sure the user has username with @ucla.edu and idnumber that is
        // a 9 digit number.
        $i = $this->usercounter;
        if (!isset($record['username'])) {
            $record['username'] = 'username' . $i . '@ucla.edu';
            $j = 2;
            while ($DB->record_exists('user',
                    array('username' => $record['username'],
                'mnethostid' => $record['mnethostid']))) {
                $record['username'] = 'username' . $i . '_' . $j . '@ucla.edu';
                $j++;
            }
        } else if (preg_match('/@ucla.edu$/', $record['username']) !== 1) {
            debugging('Given username does not end with @ucla.edu');
        }
        if (!isset($record['idnumber'])) {
            do {
                $record['idnumber'] = rand(100000000, 999999999);
            } while ($DB->record_exists('user',
                    array('username' => $record['idnumber'],
                'mnethostid' => $record['mnethostid'])));
        } else if (strlen((string) $record['idnumber']) != 9) {
            debugging('Given idnumber is not 9 digits long');
        }

        // If email isn't given, then use username. Cannot depend on Moodle's
        // create user to create an email address, because it will append
        // string '@example.com' to the username, which is not a valid email.
        if (!isset($record['email'])) {
            $record['email'] = $record['username'];
        }

        // Create the user using the regular data generator method.
        return parent::create_user($record, $options);
    }

    /**
     * Crosslists the given children array to the parent course.
     *
     * Sometimes in tests we want to do something to a course, combine it with
     * another course, and then test to see what happens.
     *
     * NOTE: This will not merge the contents of the children courses into the
     * parent. It will only update the UCLA registrar tables and invalidate any
     * existing caches.
     *
     * Procedure:
     *  1) Update ucla_request_classes table to change courseid for children to
     *     match parent courseid. Also need to set hostcourse for children to 0.
     *  2) Delete children courses.
     *
     * @param stdClass $parent  Expecting to be ucla_request_classes entry.
     * @param array $children   Expecting array of ucla_request_classes entries.
     * @return boolean          False on error, otherwise true.
     */
    public function crosslist_courses(stdClass $parent, array $children) {
        global $DB;

        try {
            // Will throw an exception if parent course does not exist.
            get_course($parent->courseid);

            // Might run into problems, so need to be able to rollback.
            $transaction = $DB->start_delegated_transaction();

            // 1) Update ucla_request_classes table to change courseid for children
            // to  match parent courseid. Also need to set hostcourse for children
            // to 0.
            $courseidstodelete = array();
            foreach ($children as $child) {
                // Make sure we are only crosslisting courses for the same term.
                if ($parent->term != $child->term) {
                    throw new Exception(sprintf('Cannot crosslist child ' .
                            'course (%s) with different term than parent (%s)',
                            $child->term, $parent->term));
                }

                if (!empty($child->courseid)) {
                    // No courseid set if course hasn't been built yet.
                    $courseidstodelete[$child->courseid] = $child->courseid;
                }
                $child->courseid = $parent->courseid;
                $child->hostcourse = 0;
                $child->action = UCLA_COURSE_BUILT;

                $DB->update_record('ucla_request_classes', $child);
            }

            // Since mappings changed, purge all caches.
            $cache = cache::make('local_ucla', 'urcmappings');
            $cache->purge();

            // Now delete children courses.
            if (!empty($courseidstodelete)) {
                foreach ($courseidstodelete as $courseid) {
                    $result = delete_course($courseid);
                    if (!$result) {
                        throw new Exception('Cannot delete child course: ' .
                        $courseid);
                    }
                }
            }

            $transaction->allow_commit();
        } catch (Exception $e) {
            $transaction->rollback($e);
            return false;
        }

        return true;
    }

    /**
     * Formats Registrar format to display format:
     *     0000SSPP -> PP . int(0000) . SS
     *
     * @param string $crsidx
     *
     * @return string           Returns formatted string.
     */
    private function format_crsidx($crsidx) {
        $num = intval(substr($crsidx, 0, 4));

        if (strlen($crsidx) < 5) {
            $ss = '  ';
        } else {
            if (strlen($crsidx) < 6) {
                $ss = $crsidx[4] . ' ';
            } else {
                $ss = $crsidx[4] . $crsidx[5];
            }
        }

        if (strlen($crsidx) < 7) {
            $pp = '  ';
        } else {
            if (strlen($crsidx) < 8) {
                $pp = $crsidx[6] . ' ';
            } else {
                $pp = $crsidx[6] . $crsidx[7];
            }
        }

        return trim(trim($pp) . $num . trim($ss));
    }

    /**
     * Formats Registrar format to display format:
     *    P000SS -> P+CSTR(CINT(000))+SS
     *
     * @param string $secidx
     *
     * @return string            Returns formatted string
     */
    private function format_secidx($secidx) {
        $retval = '';
        if (strlen($secidx) <= 3) {
            // If the string length is ~3, then just convert it to int.
            $retval = intval($secidx);
        } else if (strlen($secidx) == 5) {
            // Then maybe the last character doesn't exist... truncated.
            $num = intval(substr($secidx, 1, 3));
            $ss = trim(substr($secidx, 4, 1));
            $retval = $num . $ss;
        } else {
            // All characters should be present.
            $p = trim(substr($secidx, 0, 1));
            $num = intval(substr($secidx, 1, 3));
            $ss = trim(substr($secidx, 4, 2));
            $retval = $p . $num . $ss;
        }

        return $retval;
    }

    /**
     * Inserts given courses array into the ucla_reg_classinfo table.
     *
     * @param array $courses
     */
    private function insert_ucla_reg_classinfo(array $courses) {
        global $DB;

        $firstentry = true;
        foreach ($courses as $course) {
            $classinfo = $course;

            unset($classinfo['shortname']);
            unset($classinfo['category']);

            $DB->insert_record('ucla_reg_classinfo', $classinfo);
        }
    }

    /**
     * Inserts given courses array into the ucla_request_classes table.
     * 
     * Maps entries from courses array that correspond to the ucla_reg_classinfo
     * to the appropiate fields for ucla_request_classes and adds other
     * needed columns.
     *
     * @param int $courseid
     * @param array $courses
     */
    private function insert_ucla_request_classes($courseid, array $courses) {
        global $DB;

        // Get proper setid to use when inserting records into request table.
        $setid = $DB->get_field('ucla_request_classes',
                'MAX(setid) + 1 AS max_setid', array());

        $firstentry = true;
        foreach ($courses as $course) {
            $request = array();

            // Only the first entry should be the host course.
            if ($firstentry) {
                $request['hostcourse'] = 1;
                $firstentry = false;
            } else {
                $request['hostcourse'] = 0;
            }

            $request['term'] = $course['term'];
            $request['srs'] = $course['srs'];
            $request['department'] = $course['subj_area'];
            $request['setid'] = $setid;
            $request['action'] = UCLA_COURSE_BUILT;
            $request['course'] = $course['coursenum'] . '-' . $course['sectnum'];
            $request['courseid'] = $courseid;

            $DB->insert_record('ucla_request_classes', $request);
        }
    }

    /**
     * Returns the power set of a one dimensional array, a 2-D array.
     * [a,b,c] -> [ [a], [b], [c], [a, b], [a, c], [b, c], [a, b, c] ]
     *
     * Source: http://stackoverflow.com/a/6092999/6001
     *
     * @param array $in
     * @param int $minlength
     *
     * @return array
     */
    public function power_set(array $in, $minlength = 1) {
        $count = count($in);
        $members = pow(2, $count);
        $return = array();
        for ($i = 0; $i < $members; $i++) {
            $b = sprintf("%0" . $count . "b", $i);
            $out = array();
            for ($j = 0; $j < $count; $j++) {
                if ($b{$j} == '1')
                    $out[] = $in[$j];
            }
            if (count($out) >= $minlength) {
                $return[] = $out;
            }
        }
        return $return;
    }

    /**
     * Helper function to set division either randomly or via course's
     * 'division' config.
     *
     * @param array $course     Expected key: division.
     */
    private function set_division(array &$course) {
        global $DB;

        $divisions = $DB->get_records_menu('ucla_reg_division',
                null, 'fullname', 'code, fullname');

        // If no division is set, choose a random one from the
        // ucla_reg_division table.
        if (empty($course['division'])) {
            $codes = array_keys($divisions);
            $course['division'] = $codes[array_rand($codes)];
        } else if (empty($divisions[$course['division']])) {
            // Make sure that if someone set the division, it should exist.
            throw new Exception('Trying to add a non-existent division: ' .
            $course['division']);
        }

        // Set category id for given division.
        $divisioncategory = $DB->get_record('course_categories',
                array('idnumber' => $course['division']));
        if (empty($divisioncategory)) {
            // Create category if it didn't exist.
            $divisioncategory = $this->create_category(
                    array('name' => $divisions[$course['division']],
                          'idnumber' => $course['division']));
        }

        // Set category to division.
        $course['category'] = $divisioncategory->id;
    }

    /**
     * Helper function to generate a unique shortname.
     * 
     * @param array $course     Expected keys: term, session_group, subj_area,
     *                          crsidx, secidx. Will modify parameter to set
     *                          coursenum, sectnum, classidx, and shortname. As
     *                          well as set any missing expected values.
     * @param array $existingshortnames Other cross-lists that we are creating.
     */
    private function set_shortname(array &$course, array $existingshortnames) {
        global $DB;

        $autogenfields = array();
        while (true) {
            // Term and session_group should be predefined. Check if we need to
            // autogenerate the subj_area, crsidx, or secidx.
            // Check if we are looping again, because of the shortname already
            // exists, if so, regenerate another one.
            if (empty($course['subj_area']) || !empty($autogenfields['subj_area'])) {
                $course['subj_area'] = $this->subjareas[array_rand($this->subjareas)];
                $autogenfields['subj_area'] = true;
            }
            if (empty($course['crsidx']) || !empty($autogenfields['crsidx'])) {
                $course['crsidx'] = $this->crsidxs[array_rand($this->crsidxs)];
                $autogenfields['crsidx'] = true;
            }
            if (empty($course['secidx']) || !empty($autogenfields['secidx'])) {
                $course['secidx'] = $this->secidxs[array_rand($this->secidxs)];
                $autogenfields['secidx'] = true;
            }

            // Course creator's make_course_shortname is expecting term,
            // session_group, subj_area, coursenum, sectnum.
            $course['coursenum'] = $this->format_crsidx($course['crsidx']);
            $course['sectnum'] = $this->format_secidx($course['secidx']);
            // It appears that classidx is just a clone of secidx.
            $course['classidx'] = $course['secidx'];

            $courseobject = (object) $course;

            // The make_course_shortname method is also expecting an object.
            $shortname = uclacoursecreator::make_course_shortname($courseobject);

            // If shortname exists, try to regenerate it again.
            if (!$DB->record_exists('course', array('shortname' => $shortname))) {
                if (!in_array($shortname, $existingshortnames)) {
                    $course['shortname'] = $shortname;
                    break;
                }
            } else if (empty($autogenfields)) {
                // Cannot autogenerate shortname, since it was hardcoded.
                throw new dml_exception('duplicatefieldname', $shortname);
            }
        }
    }

    /**
     * Helper function to generate a unique term/srs combination.
     *
     * @param string $giventerm For sanity sake, make sure all cross-lists have
     *                          the same term.
     * @param array $course     Expected keys: term, session_group, srs. Will
     *                          set any missing expected values.
     * @throws Exception
     */
    private function set_termsrs(&$giventerm, array &$course) {
        global $DB;

        $autogenfields = array();
        while (true) {
            if (!empty($giventerm)) {
                if (empty($course['term'])) {
                    // Already had term set, so just use it.
                    $course['term'] = $giventerm;
                } else if ($course['term'] != $giventerm) {
                    // A term was hardcoded and it does not match the first
                    // cross-list.
                    throw new Exception('Mismatching terms');
                }
            }

            if (empty($course['term']) || !empty($autogenfields['term'])) {
                $course['term'] = $this->terms[array_rand($this->terms)];
                $autogenfields['term'] = true;
            }
            if (empty($course['srs']) || !empty($autogenfields['srs'])) {
                $course['srs'] = rand(100000000, 999999999);
                $autogenfields['srs'] = true;
            }

            if (!$DB->record_exists('ucla_request_classes',
                            array('term' => $course['term'], 'srs' => $course['srs']))) {
                if (is_summer_term($course['term'])) {
                    // Summer sessions have a session group set.
                    if (empty($course['session_group'])) {
                        $sessiongroups = array('A', 'C');
                        $course['session_group'] = $sessiongroups[array_rand($sessiongroups)];
                    }
                } else {
                    $course['session_group'] = '';
                }
                break;
            } else if (empty($autogenfields)) {
                // Term and SRS were hardcoded, cannot regen.
                $a = sprintf('term = %s and srs = %s', $course['term'],
                        $course['srs']);
                throw new dml_exception('duplicatefieldname', $a);
            }
        }

        // No given term set before, so remember it for potential future calls.
        if (empty($giventerm)) {
            $giventerm = $course['term'];
        }
    }

}